<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebXR Volume Viewer</title>
    <meta name="description"
        content="Immersive WebXR volume rendering of DICOM medical images. Experience CT and MRI scans in virtual reality with interactive 3D visualization.">
    <meta name="keywords"
        content="WebXR, VR medical imaging, 3D volume rendering, vtk.js, DICOM VR viewer, immersive medical visualization">
    <meta name="author" content="DICOM Processor">
    <meta property="og:title" content="WebXR Volume Viewer - DICOM Processor">
    <meta property="og:description"
        content="Immersive WebXR volume rendering of DICOM medical images. View CT and MRI scans in VR on Quest, Vision Pro, and more.">
    <meta property="og:type" content="website">
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            color: white;
            font-family: sans-serif;
        }

        #container {
            width: 100vw;
            height: 100vh;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            z-index: 1000;
            text-align: center;
        }

        .progress-container {
            margin-top: 15px;
            width: 300px;
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background: #333;
            border-radius: 3px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #0066cc, #00aaff);
            border-radius: 3px;
            transition: width 0.15s ease;
        }

        .progress-text {
            margin-top: 8px;
            font-size: 14px;
            color: #aaa;
        }

        #error {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: red;
            font-size: 18px;
            display: none;
            text-align: center;
            z-index: 1000;
            max-width: 80vw;
        }

        .controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-width: 220px;
            max-height: 90vh;
            overflow-y: auto;
            z-index: 100;
        }

        .controls.vr-mode {
            display: none;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        label {
            font-size: 12px;
            color: #aaa;
            display: flex;
            justify-content: space-between;
        }

        select,
        input[type="range"] {
            width: 100%;
        }

        button {
            cursor: pointer;
            padding: 8px;
            background: #444;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 14px;
        }

        button:hover {
            background: #666;
        }

        button:disabled {
            background: #222;
            color: #666;
            cursor: not-allowed;
        }

        .value-display {
            color: white;
            font-weight: bold;
        }

        #vrButton {
            background: #0066cc;
            font-weight: bold;
            padding: 10px;
        }

        #vrButton:hover:not(:disabled) {
            background: #0088ff;
        }

        #vrButton.vr-active {
            background: #cc0000;
        }

        .info-text {
            font-size: 11px;
            color: #888;
            margin-top: -5px;
        }
    </style>
</head>

<body>
    <div id="loading">
        <div id="loadingText">Loading...</div>
        <div class="progress-container">
            <div class="progress-bar"><div class="progress-fill" id="progressFill"></div></div>
            <div class="progress-text" id="progressText"></div>
        </div>
    </div>
    <div id="error"></div>
    <div id="container"></div>

    <div class="controls" id="controls" style="display: none;">
        <button id="vrButton" disabled>ðŸ¥½ Enter VR</button>
        <p class="info-text" id="vrInfo">Checking VR support...</p>

        <div class="control-group">
            <label>Color Preset</label>
            <select id="presetSelector">
                <option value="default">Default (Bone/Tissue)</option>
                <option value="blackbluewhite">Black, Blue and White</option>
                <option value="blackorangewhite">Black, Orange and White</option>
                <option value="blackbody">Black-Body Radiation</option>
                <option value="coldhot">Cold and Hot</option>
                <option value="coolwarm">Cool to Warm</option>
                <option value="grayscale">Grayscale</option>
                <option value="rainbowdesaturated">Rainbow Desaturated</option>
                <option value="warmcool">Warm to Cool</option>
                <option value="xray">X Ray</option>
            </select>
        </div>

        <div class="control-group">
            <label>Threshold Min <span id="thresholdMinValue" class="value-display">-1000</span></label>
            <input type="range" id="thresholdMinSlider" min="-2000" max="4000" value="-1000" step="10">
        </div>

        <div class="control-group">
            <label>Threshold Max <span id="thresholdMaxValue" class="value-display">3000</span></label>
            <input type="range" id="thresholdMaxSlider" min="-2000" max="4000" value="3000" step="10">
        </div>

        <div class="control-group">
            <label>Window (Contrast) <span id="windowValue" class="value-display">1.0</span></label>
            <input type="range" id="windowSlider" min="0.1" max="5.0" value="1.0" step="0.1">
        </div>

        <div class="control-group">
            <label>Opacity (Global) <span id="opacityValue" class="value-display">1.0</span></label>
            <input type="range" id="opacitySlider" min="0" max="1" value="1.0" step="0.05">
        </div>

        <div class="control-group">
            <label>Sample Distance <span id="sampleValue" class="value-display">0.7</span></label>
            <input type="range" id="sampleSlider" min="0.1" max="2.0" value="0.7" step="0.1">
        </div>

        <div class="control-group">
            <label>Gradient Opacity (Edges) <span id="gradientValue" class="value-display">0.0</span></label>
            <input type="range" id="gradientSlider" min="0.0" max="1.0" value="0.0" step="0.1">
        </div>

        <div class="control-group" style="flex-direction: row; align-items: center;">
            <input type="checkbox" id="shadingCheckbox" checked style="width: auto; margin-right: 10px;">
            <label for="shadingCheckbox" style="margin: 0; cursor: pointer;">Enable Shading</label>
        </div>

        <div class="control-group">
            <label>CVR Quality</label>
            <select id="cvrSelector">
                <option value="none">None (Fast)</option>
                <option value="gradient">Gradient Only</option>
                <option value="blended" selected>Blended CVR</option>
                <option value="full">Full Cinematic (GPU Heavy)</option>
            </select>
        </div>

        <div class="control-group">
            <label>Global Illumination <span id="giValue" class="value-display">0.1</span></label>
            <input type="range" id="giSlider" min="0.0" max="1.0" value="0.1" step="0.05">
        </div>

        <div class="control-group">
            <label>Vol. Scattering <span id="scatterValue" class="value-display">0.5</span></label>
            <input type="range" id="scatterSlider" min="0.0" max="1.0" value="0.5" step="0.05">
        </div>

        <div class="control-group" style="flex-direction: row; align-items: center;">
            <input type="checkbox" id="controllerRaysCheckbox" checked style="width: auto; margin-right: 10px;">
            <label for="controllerRaysCheckbox" style="margin: 0; cursor: pointer;">Controller Rays</label>
        </div>

        <button id="resetCameraBtn">Reset Camera</button>
    </div>

    <script type="module">
        // --- vtk.js pre-built bundle with WebXR support ---
        // Built via: npm run build:webxr (esbuild, ~2.3MB, includes vtkWebXRRenderWindowHelper)
        import {
            vtkFullScreenRenderWindow,
            vtkWebXRRenderWindowHelper,
            XrSessionTypes,
            vtkVolume,
            vtkVolumeMapper,
            vtkColorTransferFunction,
            vtkPiecewiseFunction,
            vtkXMLImageDataReader,
            vtkImageData,
            vtkDataArray,
        } from '/webxr-vtk-bundle.js';

        // --- DOM elements ---
        const container = document.getElementById('container');
        const loading = document.getElementById('loading');
        const loadingText = document.getElementById('loadingText');
        const progressFill = document.getElementById('progressFill');
        const progressTextEl = document.getElementById('progressText');
        const errorDiv = document.getElementById('error');
        const controlsEl = document.getElementById('controls');
        const vrButton = document.getElementById('vrButton');
        const vrInfo = document.getElementById('vrInfo');

        // --- Progress helpers ---
        function formatBytes(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1048576) return (bytes / 1024).toFixed(1) + ' KB';
            return (bytes / 1048576).toFixed(1) + ' MB';
        }

        function updateProgress(percent, loaded, total) {
            progressFill.style.width = percent.toFixed(1) + '%';
            if (total) {
                progressTextEl.textContent = formatBytes(loaded) + ' / ' + formatBytes(total) + '  (' + Math.round(percent) + '%)';
            } else {
                progressTextEl.textContent = formatBytes(loaded) + ' downloaded';
            }
        }

        async function fetchWithProgress(url) {
            const response = await fetch(url);
            if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);

            const contentLength = response.headers.get('Content-Length');
            if (!contentLength || !response.body) {
                const buffer = await response.arrayBuffer();
                updateProgress(100, buffer.byteLength, buffer.byteLength);
                return buffer;
            }

            const total = parseInt(contentLength, 10);
            const reader = response.body.getReader();
            const chunks = [];
            let loaded = 0;

            while (true) {
                const { done, value } = await reader.read();
                if (done) break;
                chunks.push(value);
                loaded += value.length;
                updateProgress((loaded / total) * 100, loaded, total);
            }

            const buffer = new Uint8Array(loaded);
            let offset = 0;
            for (const chunk of chunks) {
                buffer.set(chunk, offset);
                offset += chunk.length;
            }
            return buffer.buffer;
        }

        // --- State ---
        let fullScreenRenderer, renderWindow, renderer, actor, mapper;
        let xrHelper = null;
        let xrActive = false;
        let currentPreset = 'default';
        let currentMin = -1000;
        let currentMax = 3000;
        let currentWindow = 1.0;
        let currentOpacity = 1.0;
        let currentSampleDistance = 0.7;
        let currentGradientOpacity = 0.0;
        let shadingEnabled = true;

        // CVR state
        let cvrQuality = 'blended';
        let globalIllumination = 0.1;
        let volumetricScattering = 0.5;

        // XR session type: auto-detect from URL or device
        const urlParams = new URLSearchParams(window.location.search);
        let requestedXrSessionType = urlParams.get('xrSessionType');
        if (requestedXrSessionType !== null) {
            requestedXrSessionType = parseInt(requestedXrSessionType, 10);
            if (![0, 1, 2, 3].includes(requestedXrSessionType)) requestedXrSessionType = null;
        }

        function showError(msg) {
            loading.style.display = 'none';
            errorDiv.innerText = msg;
            errorDiv.style.display = 'block';
        }

        // --- NRRD Parser (custom, no extra vtk module needed) ---
        function parseNrrd(buffer) {
            const decoder = new TextDecoder();
            let header = '';
            let headerSize = 0;
            const view = new Uint8Array(buffer);

            for (let i = 0; i < view.length - 1; i++) {
                if (view[i] === 10 && view[i + 1] === 10) {
                    headerSize = i + 2;
                    header = decoder.decode(view.slice(0, i));
                    break;
                }
                if (view[i] === 13 && view[i + 1] === 10 && view[i + 2] === 13 && view[i + 3] === 10) {
                    headerSize = i + 4;
                    header = decoder.decode(view.slice(0, i));
                    break;
                }
            }

            if (headerSize === 0) throw new Error('Could not find end of NRRD header');

            const lines = header.split(/\r?\n/);
            if (!lines[0].startsWith('NRRD')) throw new Error('Invalid NRRD magic number');

            const info = {};
            for (const line of lines) {
                if (line.startsWith('#') || line.length === 0) continue;
                const colonIndex = line.indexOf(':');
                if (colonIndex !== -1) {
                    const key = line.substring(0, colonIndex).trim();
                    const value = line.substring(colonIndex + 1).trim();
                    info[key] = value;
                }
            }

            const sizes = info['sizes'] ? info['sizes'].split(/\s+/).map(Number) : [1, 1, 1];
            const type = info['type'] || 'float';

            let spacing = [1, 1, 1];
            if (info['spacings']) {
                spacing = info['spacings'].split(/\s+/).map(Number);
            } else if (info['space directions']) {
                const parts = info['space directions'].match(/\((.*?)\)/g);
                if (parts) {
                    spacing = parts.map(p => {
                        const vec = p.replace(/[()]/g, '').split(',').map(Number);
                        return Math.sqrt(vec.reduce((sum, val) => sum + val * val, 0));
                    });
                }
            }

            let origin = [0, 0, 0];
            if (info['space origin']) {
                origin = info['space origin'].replace(/[()]/g, '').split(',').map(Number);
            }

            const dataBuffer = buffer.slice(headerSize);
            let typedData;

            if (type === 'float' || type === 'double') {
                typedData = new Float32Array(dataBuffer);
            } else if (type === 'short' || type === 'signed short') {
                typedData = new Int16Array(dataBuffer);
            } else if (type === 'unsigned short') {
                typedData = new Uint16Array(dataBuffer);
            } else if (type === 'unsigned char' || type === 'uchar') {
                typedData = new Uint8Array(dataBuffer);
            } else {
                throw new Error(`Unsupported NRRD type: ${type}`);
            }

            return {
                header: { sizes, spacing, origin, type },
                data: typedData
            };
        }

        // (createVtkImageFromNrrd replaced by shared createVtkImage above)

        // --- Shared helper for manual formats ---
        function createVtkImage(header, data) {
            const imageData = vtkImageData.newInstance();
            imageData.setDimensions(header.sizes);
            imageData.setSpacing(header.spacing);
            imageData.setOrigin(header.origin);

            const dataArray = vtkDataArray.newInstance({
                name: 'Scalars',
                numberOfComponents: 1,
                values: data
            });
            imageData.getPointData().setScalars(dataArray);
            return imageData;
        }

        // --- File Loaders ---
        async function loadVti(url) {
            const buffer = await fetchWithProgress(url);
            const reader = vtkXMLImageDataReader.newInstance();
            reader.parseAsArrayBuffer(buffer);
            return reader.getOutputData();
        }

        async function loadNrrd(url) {
            const buffer = await fetchWithProgress(url);
            const { header, data } = parseNrrd(buffer);
            return createVtkImage(header, data);
        }

        // --- NIfTI ---
        async function loadNifti(url) {
            const buffer = await fetchWithProgress(url);
            const view = new DataView(buffer);

            const sizeof_hdr = view.getInt32(0, true);
            if (sizeof_hdr !== 348) throw new Error('Invalid NIfTI file: header size is not 348');

            const magic = String.fromCharCode(
                view.getUint8(344), view.getUint8(345), view.getUint8(346), view.getUint8(347)
            );
            if (magic !== 'n+1\0' && magic !== 'ni1\0') throw new Error('Invalid NIfTI magic');

            const dimX = view.getInt16(42, true);
            const dimY = view.getInt16(44, true);
            const dimZ = view.getInt16(46, true);
            const spacingX = view.getFloat32(80, true);
            const spacingY = view.getFloat32(84, true);
            const spacingZ = view.getFloat32(88, true);
            const originX = view.getFloat32(268, true);
            const originY = view.getFloat32(272, true);
            const originZ = view.getFloat32(276, true);
            const vox_offset = view.getFloat32(108, true);
            const numVoxels = dimX * dimY * dimZ;
            const pixelData = new Float32Array(buffer, Math.floor(vox_offset), numVoxels);

            return createVtkImage(
                { sizes: [dimX, dimY, dimZ], spacing: [spacingX, spacingY, spacingZ], origin: [originX, originY, originZ] },
                pixelData
            );
        }

        // --- VTK Legacy ---
        async function loadVtkLegacy(url) {
            const buffer = await fetchWithProgress(url);
            const bytes = new Uint8Array(buffer);
            const decoder = new TextDecoder('ascii');

            const searchLimit = Math.min(bytes.length, 4096);
            const headerText = decoder.decode(bytes.slice(0, searchLimit));
            const lookupIdx = headerText.indexOf('LOOKUP_TABLE default\n');

            if (lookupIdx === -1) throw new Error('Invalid VTK file: could not find LOOKUP_TABLE default');

            const headerEnd = lookupIdx + 'LOOKUP_TABLE default\n'.length;
            const headerStr = headerText.substring(0, headerEnd);
            const lines = headerStr.split('\n');

            let dimensions = null, origin = null, spacing = null, pointData = null;

            for (const line of lines) {
                const trimmed = line.trim();
                if (trimmed.startsWith('DIMENSIONS')) {
                    const parts = trimmed.split(/\s+/);
                    dimensions = [parseInt(parts[1]), parseInt(parts[2]), parseInt(parts[3])];
                } else if (trimmed.startsWith('ORIGIN')) {
                    const parts = trimmed.split(/\s+/);
                    origin = [parseFloat(parts[1]), parseFloat(parts[2]), parseFloat(parts[3])];
                } else if (trimmed.startsWith('SPACING')) {
                    const parts = trimmed.split(/\s+/);
                    spacing = [parseFloat(parts[1]), parseFloat(parts[2]), parseFloat(parts[3])];
                } else if (trimmed.startsWith('POINT_DATA')) {
                    const parts = trimmed.split(/\s+/);
                    pointData = parseInt(parts[1]);
                }
            }

            if (!dimensions || !origin || !spacing || !pointData) {
                throw new Error('Invalid VTK file: missing required header fields');
            }

            const pixelData = new Float32Array(buffer.slice(headerEnd, headerEnd + pointData * 4));

            return createVtkImage(
                { sizes: dimensions, spacing: spacing, origin: origin },
                pixelData
            );
        }

        // --- Format detection ---
        function detectFormat(url) {
            const ext = url.split('.').pop().toLowerCase().split('?')[0];
            const map = { vti: 'vti', nrrd: 'nrrd', nii: 'nifti', vtk: 'vtk' };
            return map[ext] || null;
        }

        async function loadVolume(url) {
            const format = detectFormat(url);
            const labels = { vti: 'VTI', nrrd: 'NRRD', nifti: 'NIfTI', vtk: 'VTK Legacy' };
            loadingText.textContent = 'Loading ' + (labels[format] || 'volume') + '...';

            switch (format) {
                case 'vti': return loadVti(url);
                case 'nrrd': return loadNrrd(url);
                case 'nifti': return loadNifti(url);
                case 'vtk': return loadVtkLegacy(url);
                default: throw new Error('Unsupported format. Use .vti, .nrrd, .nii, or .vtk');
            }
        }

        // --- Transfer Functions (all presets) ---
        function updateTransferFunction() {
            if (!actor) return;

            const ctfun = vtkColorTransferFunction.newInstance();
            const ofun = vtkPiecewiseFunction.newInstance();

            const min = parseFloat(currentMin);
            const max = parseFloat(currentMax);
            const widthScale = parseFloat(currentWindow);
            const opacityScale = parseFloat(currentOpacity);

            const center = (currentPreset === 'default') ? 100 :
                (currentPreset === 'grayscale' || currentPreset === 'xray') ? 1000 : 500;

            const t = (x) => center + (x - center) * widthScale;

            const addOp = (x, y) => {
                if (x >= min && x <= max) ofun.addPoint(x, y * opacityScale);
            };

            ofun.addPoint(min - 1, 0);
            ofun.addPoint(min, 0);

            if (currentPreset === 'default') {
                ctfun.addRGBPoint(t(-3024), 0, 0, 0);
                ctfun.addRGBPoint(t(-77), 0.549, 0.25, 0.149);
                ctfun.addRGBPoint(t(94), 0.882, 0.603, 0.29);
                ctfun.addRGBPoint(t(179), 1, 0.937, 0.952);
                ctfun.addRGBPoint(t(260), 1, 1, 1);
                ctfun.addRGBPoint(t(3071), 1, 1, 1);
                addOp(t(-3024), 0); addOp(t(-77), 0); addOp(t(94), 0.29);
                addOp(t(179), 0.55); addOp(t(260), 0.84); addOp(t(3071), 0.875);
            } else if (currentPreset === 'grayscale') {
                ctfun.addRGBPoint(t(-1000), 0, 0, 0);
                ctfun.addRGBPoint(t(3000), 1, 1, 1);
                addOp(t(-1000), 0); addOp(t(0), 0); addOp(t(3000), 1);
            } else if (currentPreset === 'xray') {
                ctfun.addRGBPoint(t(-1000), 1, 1, 1);
                ctfun.addRGBPoint(t(3000), 0, 0, 0);
                addOp(t(-1000), 0); addOp(t(0), 0.1); addOp(t(3000), 1);
            } else if (currentPreset === 'blackbluewhite') {
                ctfun.addRGBPoint(t(-1000), 0, 0, 0);
                ctfun.addRGBPoint(t(500), 0, 0, 1);
                ctfun.addRGBPoint(t(2000), 1, 1, 1);
                addOp(t(-1000), 0); addOp(t(0), 0); addOp(t(2000), 0.8);
            } else if (currentPreset === 'blackorangewhite') {
                ctfun.addRGBPoint(t(-1000), 0, 0, 0);
                ctfun.addRGBPoint(t(500), 1, 0.5, 0);
                ctfun.addRGBPoint(t(2000), 1, 1, 1);
                addOp(t(-1000), 0); addOp(t(0), 0); addOp(t(2000), 0.8);
            } else if (currentPreset === 'blackbody') {
                ctfun.addRGBPoint(t(-1000), 0, 0, 0);
                ctfun.addRGBPoint(t(0), 0.5, 0, 0);
                ctfun.addRGBPoint(t(500), 1, 0, 0);
                ctfun.addRGBPoint(t(1000), 1, 0.5, 0);
                ctfun.addRGBPoint(t(1500), 1, 1, 0);
                ctfun.addRGBPoint(t(2000), 1, 1, 1);
                addOp(t(-1000), 0); addOp(t(0), 0); addOp(t(2000), 0.8);
            } else if (currentPreset === 'coolwarm') {
                ctfun.addRGBPoint(t(-1000), 0.23, 0.30, 0.75);
                ctfun.addRGBPoint(t(500), 0.87, 0.87, 0.87);
                ctfun.addRGBPoint(t(2000), 0.71, 0.02, 0.15);
                addOp(t(-1000), 0); addOp(t(0), 0); addOp(t(2000), 0.8);
            } else if (currentPreset === 'warmcool') {
                ctfun.addRGBPoint(t(-1000), 0.71, 0.02, 0.15);
                ctfun.addRGBPoint(t(500), 0.87, 0.87, 0.87);
                ctfun.addRGBPoint(t(2000), 0.23, 0.30, 0.75);
                addOp(t(-1000), 0); addOp(t(0), 0); addOp(t(2000), 0.8);
            } else if (currentPreset === 'coldhot') {
                ctfun.addRGBPoint(t(-1000), 0, 0, 0.5);
                ctfun.addRGBPoint(t(0), 0, 0, 1);
                ctfun.addRGBPoint(t(500), 0.5, 0, 0.5);
                ctfun.addRGBPoint(t(1000), 1, 0, 0);
                ctfun.addRGBPoint(t(1500), 1, 0.5, 0);
                ctfun.addRGBPoint(t(2000), 1, 1, 1);
                addOp(t(-1000), 0); addOp(t(0), 0); addOp(t(2000), 0.8);
            } else if (currentPreset === 'rainbowdesaturated') {
                ctfun.addRGBPoint(t(-1000), 0.28, 0.28, 0.86);
                ctfun.addRGBPoint(t(-200), 0.0, 0.66, 0.66);
                ctfun.addRGBPoint(t(400), 0.0, 0.78, 0.0);
                ctfun.addRGBPoint(t(1000), 0.90, 0.90, 0.0);
                ctfun.addRGBPoint(t(1600), 0.90, 0.45, 0.0);
                ctfun.addRGBPoint(t(2000), 0.70, 0.02, 0.15);
                addOp(t(-1000), 0); addOp(t(0), 0); addOp(t(2000), 0.8);
            }

            ofun.addPoint(max, 0);
            ofun.addPoint(max + 1, 0);

            actor.getProperty().setRGBTransferFunction(0, ctfun);
            actor.getProperty().setScalarOpacity(0, ofun);

            if (renderWindow) renderWindow.render();
        }

        // --- WebXR Support (VR + AR auto-detection) ---
        // XrSessionTypes: 0=HmdVR, 1=MobileAR, 2=LookingGlassVR, 3=HmdAR
        async function setupWebXR() {
            if (!navigator.xr) {
                vrButton.disabled = true;
                vrInfo.innerHTML = 'WebXR not available. <b>Use HTTPS</b> (port 3443) for VR on Quest/Vision Pro.';
                return;
            }

            try {
                // Auto-detect session type if not specified via URL
                if (requestedXrSessionType === null) {
                    const arSupported = await navigator.xr.isSessionSupported('immersive-ar').catch(() => false);
                    const vrSupported = await navigator.xr.isSessionSupported('immersive-vr').catch(() => false);

                    if (vrSupported) {
                        // Default to HMD VR; user can switch to AR via ?xrSessionType=3
                        requestedXrSessionType = XrSessionTypes.HmdVR;
                    } else if (arSupported) {
                        requestedXrSessionType = XrSessionTypes.MobileAR;
                    }
                }

                if (requestedXrSessionType !== null) {
                    vrButton.disabled = false;
                    const isAR = [XrSessionTypes.MobileAR, XrSessionTypes.HmdAR].includes(requestedXrSessionType);
                    const modeLabel = isAR ? 'AR' : 'VR';
                    vrButton.textContent = isAR ? 'ðŸ“± Enter AR' : 'ðŸ¥½ Enter VR';
                    vrInfo.textContent = `${modeLabel} supported! Click to enter immersive ${modeLabel}.`;
                    vrInfo.style.color = '#10b981';
                    vrButton.addEventListener('click', toggleXR);
                } else {
                    vrButton.disabled = true;
                    vrInfo.textContent = 'No XR device detected. Desktop mode only.';
                }
            } catch (e) {
                vrButton.disabled = true;
                vrInfo.textContent = 'XR check failed: ' + e.message;
            }
        }

        async function toggleXR() {
            const isAR = [XrSessionTypes.MobileAR, XrSessionTypes.HmdAR].includes(requestedXrSessionType);
            const modeLabel = isAR ? 'AR' : 'VR';

            if (xrActive) {
                xrHelper.stopXR();
                xrActive = false;
                vrButton.textContent = isAR ? 'ðŸ“± Enter AR' : 'ðŸ¥½ Enter VR';
                vrButton.classList.remove('vr-active');
                controlsEl.classList.remove('vr-mode');
            } else {
                try {
                    xrHelper.startXR(requestedXrSessionType);
                    xrActive = true;
                    vrButton.textContent = 'ðŸšª Exit ' + modeLabel;
                    vrButton.classList.add('vr-active');
                    controlsEl.classList.add('vr-mode');
                } catch (e) {
                    console.error('Failed to start ' + modeLabel + ':', e);
                    vrInfo.textContent = 'Failed to start ' + modeLabel + ': ' + e.message;
                    vrInfo.style.color = '#ef4444';
                }
            }
        }

        // --- CVR (Cinematic Volume Rendering) ---
        function applyCVR(quality) {
            if (!actor || !mapper) return;
            const prop = actor.getProperty();

            // Check if CVR methods are available (vtk.js >= 29+)
            const hasCVR = typeof prop.setGlobalIlluminationReach === 'function';
            if (!hasCVR && quality !== 'none') {
                console.warn('CVR not available in this vtk.js build. Falling back to gradient shading.');
                quality = 'none';
            }

            switch (quality) {
                case 'none':
                    prop.setShade(shadingEnabled);
                    if (hasCVR) {
                        prop.setGlobalIlluminationReach(0.0);
                        prop.setVolumetricScatteringBlending(0.0);
                    }
                    break;
                case 'gradient':
                    prop.setShade(true);
                    prop.setGlobalIlluminationReach(0.0);
                    prop.setVolumetricScatteringBlending(0.0);
                    mapper.setAutoAdjustSampleDistances(false);
                    break;
                case 'blended':
                    prop.setShade(true);
                    prop.setAmbient(0.2);
                    prop.setDiffuse(1.3);
                    prop.setSpecular(0.0);
                    prop.setGlobalIlluminationReach(globalIllumination);
                    prop.setVolumetricScatteringBlending(volumetricScattering);
                    mapper.setVolumeShadowSamplingDistFactor(1.0);
                    mapper.setAutoAdjustSampleDistances(false);
                    break;
                case 'full':
                    prop.setShade(true);
                    prop.setAmbient(0.0);
                    prop.setDiffuse(2.0);
                    prop.setSpecular(0.0);
                    prop.setGlobalIlluminationReach(1.0);
                    prop.setVolumetricScatteringBlending(1.0);
                    mapper.setVolumeShadowSamplingDistFactor(1.0);
                    mapper.setAutoAdjustSampleDistances(false);
                    break;
            }
            renderWindow.render();
        }

        // --- Init Viewer ---
        function initViewer(imageData) {
            fullScreenRenderer = vtkFullScreenRenderWindow.newInstance({
                rootContainer: container,
                background: [0, 0, 0]
            });

            renderWindow = fullScreenRenderer.getRenderWindow();
            renderer = fullScreenRenderer.getRenderer();

            // Create WebXR helper with the API-specific render window (critical!)
            xrHelper = vtkWebXRRenderWindowHelper.newInstance({
                renderWindow: fullScreenRenderer.getApiSpecificRenderWindow(),
            });

            // Enable controller ray visualization in VR
            if (typeof xrHelper.setDrawControllersRay === 'function') {
                xrHelper.setDrawControllersRay(true);
            }

            actor = vtkVolume.newInstance();
            mapper = vtkVolumeMapper.newInstance();

            // Smart sample distance: compute from voxel spacing (Kitware approach)
            const spacing = imageData.getSpacing();
            const autoSampleDist = 0.7 * Math.sqrt(
                spacing[0] * spacing[0] + spacing[1] * spacing[1] + spacing[2] * spacing[2]
            );
            currentSampleDistance = parseFloat(autoSampleDist.toFixed(2));
            mapper.setSampleDistance(currentSampleDistance);
            document.getElementById('sampleSlider').value = currentSampleDistance;
            document.getElementById('sampleValue').innerText = currentSampleDistance.toFixed(1);

            actor.setMapper(mapper);
            mapper.setInputData(imageData);

            updateTransferFunction();
            actor.getProperty().setInterpolationTypeToLinear();

            // Apply default CVR quality (blended)
            applyCVR(cvrQuality);

            renderer.addVolume(actor);
            renderer.resetCamera();
            renderWindow.render();

            loading.style.display = 'none';
            controlsEl.style.display = 'flex';

            // Wire up controls
            setupControls();

            // Check WebXR support (VR + AR)
            setupWebXR();
        }

        // --- UI Controls ---
        function setupControls() {
            document.getElementById('presetSelector').addEventListener('change', (e) => {
                currentPreset = e.target.value;
                updateTransferFunction();
            });

            document.getElementById('thresholdMinSlider').addEventListener('input', (e) => {
                currentMin = e.target.value;
                document.getElementById('thresholdMinValue').innerText = e.target.value;
                updateTransferFunction();
            });

            document.getElementById('thresholdMaxSlider').addEventListener('input', (e) => {
                currentMax = e.target.value;
                document.getElementById('thresholdMaxValue').innerText = e.target.value;
                updateTransferFunction();
            });

            document.getElementById('windowSlider').addEventListener('input', (e) => {
                currentWindow = e.target.value;
                document.getElementById('windowValue').innerText = e.target.value;
                updateTransferFunction();
            });

            document.getElementById('opacitySlider').addEventListener('input', (e) => {
                currentOpacity = e.target.value;
                document.getElementById('opacityValue').innerText = e.target.value;
                updateTransferFunction();
            });

            document.getElementById('sampleSlider').addEventListener('input', (e) => {
                currentSampleDistance = parseFloat(e.target.value);
                document.getElementById('sampleValue').innerText = currentSampleDistance.toFixed(1);
                if (actor) {
                    actor.getMapper().setSampleDistance(currentSampleDistance);
                    renderWindow.render();
                }
            });

            document.getElementById('gradientSlider').addEventListener('input', (e) => {
                currentGradientOpacity = parseFloat(e.target.value);
                document.getElementById('gradientValue').innerText = currentGradientOpacity.toFixed(1);
                if (actor) {
                    if (currentGradientOpacity > 0) {
                        actor.getProperty().setUseGradientOpacity(0, true);
                        const go = vtkPiecewiseFunction.newInstance();
                        go.addPoint(0, 1.0 - (currentGradientOpacity * 0.5));
                        go.addPoint(255, 1.0);
                        actor.getProperty().setGradientOpacity(0, go);
                    } else {
                        actor.getProperty().setUseGradientOpacity(0, false);
                    }
                    renderWindow.render();
                }
            });

            document.getElementById('shadingCheckbox').addEventListener('change', (e) => {
                shadingEnabled = e.target.checked;
                if (actor) {
                    actor.getProperty().setShade(shadingEnabled);
                    renderWindow.render();
                }
            });

            // --- CVR controls ---
            document.getElementById('cvrSelector').addEventListener('change', (e) => {
                cvrQuality = e.target.value;
                // Sync sliders to match preset
                if (cvrQuality === 'blended') {
                    globalIllumination = 0.1;
                    volumetricScattering = 0.5;
                } else if (cvrQuality === 'full') {
                    globalIllumination = 1.0;
                    volumetricScattering = 1.0;
                } else {
                    globalIllumination = 0.0;
                    volumetricScattering = 0.0;
                }
                document.getElementById('giSlider').value = globalIllumination;
                document.getElementById('giValue').innerText = globalIllumination.toFixed(2);
                document.getElementById('scatterSlider').value = volumetricScattering;
                document.getElementById('scatterValue').innerText = volumetricScattering.toFixed(2);
                applyCVR(cvrQuality);
            });

            document.getElementById('giSlider').addEventListener('input', (e) => {
                globalIllumination = parseFloat(e.target.value);
                document.getElementById('giValue').innerText = globalIllumination.toFixed(2);
                if (actor && typeof actor.getProperty().setGlobalIlluminationReach === 'function') {
                    actor.getProperty().setGlobalIlluminationReach(globalIllumination);
                    renderWindow.render();
                }
            });

            document.getElementById('scatterSlider').addEventListener('input', (e) => {
                volumetricScattering = parseFloat(e.target.value);
                document.getElementById('scatterValue').innerText = volumetricScattering.toFixed(2);
                if (actor && typeof actor.getProperty().setVolumetricScatteringBlending === 'function') {
                    actor.getProperty().setVolumetricScatteringBlending(volumetricScattering);
                    renderWindow.render();
                }
            });

            // Controller rays toggle
            document.getElementById('controllerRaysCheckbox').addEventListener('change', (e) => {
                if (xrHelper && typeof xrHelper.setDrawControllersRay === 'function') {
                    xrHelper.setDrawControllersRay(e.target.checked);
                }
            });

            document.getElementById('resetCameraBtn').addEventListener('click', () => {
                if (renderer) {
                    renderer.resetCamera();
                    renderWindow.render();
                }
            });
        }

        // --- Main ---
        const fileUrl = urlParams.get('file') || urlParams.get('fileURL');

        if (!fileUrl) {
            showError('No file specified. Use ?file=path/to/volume.vti|.nrrd|.vtk|.nii');
        } else {
            try {
                const imageData = await loadVolume(fileUrl);
                initViewer(imageData);
            } catch (e) {
                showError('Failed to load: ' + e.message);
                console.error(e);
            }
        }
    </script>
</body>

</html>
